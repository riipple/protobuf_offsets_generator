// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protobufs.proto

#include "protobufs.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgVector::CMsgVector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.w_)*/0} {}
struct CMsgVectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgVectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgVectorDefaultTypeInternal() {}
  union {
    CMsgVector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgVectorDefaultTypeInternal _CMsgVector_default_instance_;
PROTOBUF_CONSTEXPR CMsgQAngle::CMsgQAngle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0} {}
struct CMsgQAngleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgQAngleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgQAngleDefaultTypeInternal() {}
  union {
    CMsgQAngle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgQAngleDefaultTypeInternal _CMsgQAngle_default_instance_;
PROTOBUF_CONSTEXPR CInButtonStatePB::CInButtonStatePB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buttonstate1_)*/uint64_t{0u}
  , /*decltype(_impl_.buttonstate2_)*/uint64_t{0u}
  , /*decltype(_impl_.buttonstate3_)*/uint64_t{0u}} {}
struct CInButtonStatePBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CInButtonStatePBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CInButtonStatePBDefaultTypeInternal() {}
  union {
    CInButtonStatePB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CInButtonStatePBDefaultTypeInternal _CInButtonStatePB_default_instance_;
PROTOBUF_CONSTEXPR CSubtickMoveStep::CSubtickMoveStep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.button_)*/uint64_t{0u}
  , /*decltype(_impl_.pressed_)*/false
  , /*decltype(_impl_.when_)*/0} {}
struct CSubtickMoveStepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSubtickMoveStepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSubtickMoveStepDefaultTypeInternal() {}
  union {
    CSubtickMoveStep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSubtickMoveStepDefaultTypeInternal _CSubtickMoveStep_default_instance_;
PROTOBUF_CONSTEXPR CBaseUserCmdPB::CBaseUserCmdPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subtick_moves_)*/{}
  , /*decltype(_impl_.move_crc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.buttons_pb_)*/nullptr
  , /*decltype(_impl_.viewangles_)*/nullptr
  , /*decltype(_impl_.command_number_)*/0
  , /*decltype(_impl_.tick_count_)*/0
  , /*decltype(_impl_.forwardmove_)*/0
  , /*decltype(_impl_.leftmove_)*/0
  , /*decltype(_impl_.upmove_)*/0
  , /*decltype(_impl_.impulse_)*/0
  , /*decltype(_impl_.weaponselect_)*/0
  , /*decltype(_impl_.random_seed_)*/0
  , /*decltype(_impl_.mousedx_)*/0
  , /*decltype(_impl_.mousedy_)*/0
  , /*decltype(_impl_.consumed_server_angle_changes_)*/0u
  , /*decltype(_impl_.cmd_flags_)*/0
  , /*decltype(_impl_.pawn_entity_handle_)*/16777215u} {}
struct CBaseUserCmdPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CBaseUserCmdPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CBaseUserCmdPBDefaultTypeInternal() {}
  union {
    CBaseUserCmdPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CBaseUserCmdPBDefaultTypeInternal _CBaseUserCmdPB_default_instance_;
PROTOBUF_CONSTEXPR CSGOInterpolationInfoPB::CSGOInterpolationInfoPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.frac_)*/0
  , /*decltype(_impl_.src_tick_)*/-1
  , /*decltype(_impl_.dst_tick_)*/-1} {}
struct CSGOInterpolationInfoPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSGOInterpolationInfoPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSGOInterpolationInfoPBDefaultTypeInternal() {}
  union {
    CSGOInterpolationInfoPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSGOInterpolationInfoPBDefaultTypeInternal _CSGOInterpolationInfoPB_default_instance_;
PROTOBUF_CONSTEXPR CSGOInputHistoryEntryPB::CSGOInputHistoryEntryPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.view_angles_)*/nullptr
  , /*decltype(_impl_.shoot_position_)*/nullptr
  , /*decltype(_impl_.target_head_pos_check_)*/nullptr
  , /*decltype(_impl_.target_abs_pos_check_)*/nullptr
  , /*decltype(_impl_.target_abs_ang_check_)*/nullptr
  , /*decltype(_impl_.cl_interp_)*/nullptr
  , /*decltype(_impl_.sv_interp0_)*/nullptr
  , /*decltype(_impl_.sv_interp1_)*/nullptr
  , /*decltype(_impl_.player_interp_)*/nullptr
  , /*decltype(_impl_.render_tick_count_)*/0
  , /*decltype(_impl_.render_tick_fraction_)*/0
  , /*decltype(_impl_.player_tick_count_)*/0
  , /*decltype(_impl_.player_tick_fraction_)*/0
  , /*decltype(_impl_.frame_number_)*/0
  , /*decltype(_impl_.target_ent_index_)*/-1} {}
struct CSGOInputHistoryEntryPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSGOInputHistoryEntryPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSGOInputHistoryEntryPBDefaultTypeInternal() {}
  union {
    CSGOInputHistoryEntryPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSGOInputHistoryEntryPBDefaultTypeInternal _CSGOInputHistoryEntryPB_default_instance_;
PROTOBUF_CONSTEXPR CSGOUserCmdPB::CSGOUserCmdPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.input_history_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.weapon_decision_)*/0
  , /*decltype(_impl_.weapon_decision_weapon_)*/0
  , /*decltype(_impl_.attack3_start_history_index_)*/-1
  , /*decltype(_impl_.attack1_start_history_index_)*/-1
  , /*decltype(_impl_.attack2_start_history_index_)*/-1} {}
struct CSGOUserCmdPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSGOUserCmdPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSGOUserCmdPBDefaultTypeInternal() {}
  union {
    CSGOUserCmdPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSGOUserCmdPBDefaultTypeInternal _CSGOUserCmdPB_default_instance_;
PROTOBUF_CONSTEXPR CUserMessage_Inventory_Response_InventoryDetail::CUserMessage_Inventory_Response_InventoryDetail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.primary_)*/int64_t{0}
  , /*decltype(_impl_.offset_)*/int64_t{0}
  , /*decltype(_impl_.first_)*/int64_t{0}
  , /*decltype(_impl_.index_)*/0
  , /*decltype(_impl_.base_detail_)*/0
  , /*decltype(_impl_.base_)*/int64_t{0}
  , /*decltype(_impl_.base_time_)*/0
  , /*decltype(_impl_.base_hash_)*/0} {}
struct CUserMessage_Inventory_Response_InventoryDetailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CUserMessage_Inventory_Response_InventoryDetailDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CUserMessage_Inventory_Response_InventoryDetailDefaultTypeInternal() {}
  union {
    CUserMessage_Inventory_Response_InventoryDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CUserMessage_Inventory_Response_InventoryDetailDefaultTypeInternal _CUserMessage_Inventory_Response_InventoryDetail_default_instance_;
PROTOBUF_CONSTEXPR CUserMessage_Inventory_Response::CUserMessage_Inventory_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.inventories_)*/{}
  , /*decltype(_impl_.inventories2_)*/{}
  , /*decltype(_impl_.inventories3_)*/{}
  , /*decltype(_impl_.crc_)*/0u
  , /*decltype(_impl_.item_count_)*/0
  , /*decltype(_impl_.osversion_)*/0
  , /*decltype(_impl_.perf_time_)*/0
  , /*decltype(_impl_.client_timestamp_)*/0
  , /*decltype(_impl_.platform_)*/0
  , /*decltype(_impl_.inv_type_)*/0
  , /*decltype(_impl_.build_version_)*/0
  , /*decltype(_impl_.start_time_)*/int64_t{0}
  , /*decltype(_impl_.instance_)*/0} {}
struct CUserMessage_Inventory_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CUserMessage_Inventory_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CUserMessage_Inventory_ResponseDefaultTypeInternal() {}
  union {
    CUserMessage_Inventory_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CUserMessage_Inventory_ResponseDefaultTypeInternal _CUserMessage_Inventory_Response_default_instance_;
static ::_pb::Metadata file_level_metadata_protobufs_2eproto[10];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_protobufs_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_protobufs_2eproto = nullptr;

const uint32_t TableStruct_protobufs_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CMsgVector, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgVector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgVector, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::CMsgVector, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::CMsgVector, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::CMsgVector, _impl_.w_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgQAngle, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgQAngle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgQAngle, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::CMsgQAngle, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::CMsgQAngle, _impl_.z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_.buttonstate1_),
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_.buttonstate2_),
  PROTOBUF_FIELD_OFFSET(::CInButtonStatePB, _impl_.buttonstate3_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _impl_.button_),
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _impl_.pressed_),
  PROTOBUF_FIELD_OFFSET(::CSubtickMoveStep, _impl_.when_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.command_number_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.tick_count_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.buttons_pb_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.viewangles_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.forwardmove_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.leftmove_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.upmove_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.impulse_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.weaponselect_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.random_seed_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.mousedx_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.mousedy_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.pawn_entity_handle_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.subtick_moves_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.move_crc_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.consumed_server_angle_changes_),
  PROTOBUF_FIELD_OFFSET(::CBaseUserCmdPB, _impl_.cmd_flags_),
  3,
  4,
  1,
  2,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  15,
  ~0u,
  0,
  13,
  14,
  PROTOBUF_FIELD_OFFSET(::CSGOInterpolationInfoPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSGOInterpolationInfoPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSGOInterpolationInfoPB, _impl_.src_tick_),
  PROTOBUF_FIELD_OFFSET(::CSGOInterpolationInfoPB, _impl_.dst_tick_),
  PROTOBUF_FIELD_OFFSET(::CSGOInterpolationInfoPB, _impl_.frac_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.view_angles_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.render_tick_count_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.render_tick_fraction_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.player_tick_count_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.player_tick_fraction_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.cl_interp_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.sv_interp0_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.sv_interp1_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.player_interp_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.frame_number_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.target_ent_index_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.shoot_position_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.target_head_pos_check_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.target_abs_pos_check_),
  PROTOBUF_FIELD_OFFSET(::CSGOInputHistoryEntryPB, _impl_.target_abs_ang_check_),
  0,
  9,
  10,
  11,
  12,
  5,
  6,
  7,
  8,
  13,
  14,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.input_history_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.attack1_start_history_index_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.attack2_start_history_index_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.attack3_start_history_index_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.weapon_decision_),
  PROTOBUF_FIELD_OFFSET(::CSGOUserCmdPB, _impl_.weapon_decision_weapon_),
  0,
  ~0u,
  4,
  5,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_.primary_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_.first_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_.base_name_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_.base_detail_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_.base_time_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response_InventoryDetail, _impl_.base_hash_),
  5,
  2,
  3,
  4,
  7,
  0,
  1,
  6,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.crc_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.item_count_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.osversion_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.perf_time_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.client_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.platform_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.inventories_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.inventories2_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.inventories3_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.inv_type_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.build_version_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.instance_),
  PROTOBUF_FIELD_OFFSET(::CUserMessage_Inventory_Response, _impl_.start_time_),
  0,
  1,
  2,
  3,
  4,
  5,
  ~0u,
  ~0u,
  ~0u,
  6,
  7,
  9,
  8,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::CMsgVector)},
  { 14, 23, -1, sizeof(::CMsgQAngle)},
  { 26, 35, -1, sizeof(::CInButtonStatePB)},
  { 38, 47, -1, sizeof(::CSubtickMoveStep)},
  { 50, 73, -1, sizeof(::CBaseUserCmdPB)},
  { 90, 99, -1, sizeof(::CSGOInterpolationInfoPB)},
  { 102, 123, -1, sizeof(::CSGOInputHistoryEntryPB)},
  { 138, 151, -1, sizeof(::CSGOUserCmdPB)},
  { 158, 174, -1, sizeof(::CUserMessage_Inventory_Response_InventoryDetail)},
  { 184, 203, -1, sizeof(::CUserMessage_Inventory_Response)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CMsgVector_default_instance_._instance,
  &::_CMsgQAngle_default_instance_._instance,
  &::_CInButtonStatePB_default_instance_._instance,
  &::_CSubtickMoveStep_default_instance_._instance,
  &::_CBaseUserCmdPB_default_instance_._instance,
  &::_CSGOInterpolationInfoPB_default_instance_._instance,
  &::_CSGOInputHistoryEntryPB_default_instance_._instance,
  &::_CSGOUserCmdPB_default_instance_._instance,
  &::_CUserMessage_Inventory_Response_InventoryDetail_default_instance_._instance,
  &::_CUserMessage_Inventory_Response_default_instance_._instance,
};

const char descriptor_table_protodef_protobufs_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017protobufs.proto\"8\n\nCMsgVector\022\t\n\001x\030\001 \001"
  "(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\022\t\n\001w\030\004 \001(\002\"-\n\nC"
  "MsgQAngle\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001"
  "(\002\"T\n\020CInButtonStatePB\022\024\n\014buttonstate1\030\001"
  " \001(\004\022\024\n\014buttonstate2\030\002 \001(\004\022\024\n\014buttonstat"
  "e3\030\003 \001(\004\"A\n\020CSubtickMoveStep\022\016\n\006button\030\001"
  " \001(\004\022\017\n\007pressed\030\002 \001(\010\022\014\n\004when\030\003 \001(\002\"\265\003\n\016"
  "CBaseUserCmdPB\022\026\n\016command_number\030\001 \001(\005\022\022"
  "\n\ntick_count\030\002 \001(\005\022%\n\nbuttons_pb\030\003 \001(\0132\021"
  ".CInButtonStatePB\022\037\n\nviewangles\030\004 \001(\0132\013."
  "CMsgQAngle\022\023\n\013forwardmove\030\005 \001(\002\022\020\n\010leftm"
  "ove\030\006 \001(\002\022\016\n\006upmove\030\007 \001(\002\022\017\n\007impulse\030\010 \001"
  "(\005\022\024\n\014weaponselect\030\t \001(\005\022\023\n\013random_seed\030"
  "\n \001(\005\022\017\n\007mousedx\030\013 \001(\005\022\017\n\007mousedy\030\014 \001(\005\022"
  "$\n\022pawn_entity_handle\030\016 \001(\r:\01016777215\022(\n"
  "\rsubtick_moves\030\022 \003(\0132\021.CSubtickMoveStep\022"
  "\020\n\010move_crc\030\023 \001(\014\022%\n\035consumed_server_ang"
  "le_changes\030\024 \001(\r\022\021\n\tcmd_flags\030\025 \001(\005\"V\n\027C"
  "SGOInterpolationInfoPB\022\024\n\010src_tick\030\001 \001(\005"
  ":\002-1\022\024\n\010dst_tick\030\002 \001(\005:\002-1\022\017\n\004frac\030\003 \001(\002"
  ":\0010\"\302\004\n\027CSGOInputHistoryEntryPB\022 \n\013view_"
  "angles\030\002 \001(\0132\013.CMsgQAngle\022\031\n\021render_tick"
  "_count\030\004 \001(\005\022\034\n\024render_tick_fraction\030\005 \001"
  "(\002\022\031\n\021player_tick_count\030\006 \001(\005\022\034\n\024player_"
  "tick_fraction\030\007 \001(\002\022+\n\tcl_interp\030\014 \001(\0132\030"
  ".CSGOInterpolationInfoPB\022,\n\nsv_interp0\030\r"
  " \001(\0132\030.CSGOInterpolationInfoPB\022,\n\nsv_int"
  "erp1\030\016 \001(\0132\030.CSGOInterpolationInfoPB\022/\n\r"
  "player_interp\030\017 \001(\0132\030.CSGOInterpolationI"
  "nfoPB\022\024\n\014frame_number\030\024 \001(\005\022\034\n\020target_en"
  "t_index\030\010 \001(\005:\002-1\022#\n\016shoot_position\030\003 \001("
  "\0132\013.CMsgVector\022*\n\025target_head_pos_check\030"
  "\t \001(\0132\013.CMsgVector\022)\n\024target_abs_pos_che"
  "ck\030\n \001(\0132\013.CMsgVector\022)\n\024target_abs_ang_"
  "check\030\013 \001(\0132\013.CMsgQAngle\"\246\003\n\rCSGOUserCmd"
  "PB\022\035\n\004base\030\001 \001(\0132\017.CBaseUserCmdPB\022/\n\rinp"
  "ut_history\030\002 \003(\0132\030.CSGOInputHistoryEntry"
  "PB\022\'\n\033attack1_start_history_index\030\006 \001(\005:"
  "\002-1\022\'\n\033attack2_start_history_index\030\007 \001(\005"
  ":\002-1\022\'\n\033attack3_start_history_index\030\010 \001("
  "\005:\002-1\022@\n\017weapon_decision\030\t \001(\0162\036.CSGOUse"
  "rCmdPB.EWeaponDecision:\007k_eNone\022\036\n\026weapo"
  "n_decision_weapon\030\n \001(\005\"h\n\017EWeaponDecisi"
  "on\022\013\n\007k_eNone\020\000\022\024\n\020k_ePrimaryAttack\020\001\022\026\n"
  "\022k_eSecondaryAttack\020\002\022\013\n\007k_eZoom\020\003\022\r\n\tk_"
  "eReload\020\004\"\367\004\n\037CUserMessage_Inventory_Res"
  "ponse\022\013\n\003crc\030\001 \001(\007\022\022\n\nitem_count\030\002 \001(\005\022\021"
  "\n\tosversion\030\005 \001(\005\022\021\n\tperf_time\030\006 \001(\005\022\030\n\020"
  "client_timestamp\030\007 \001(\005\022\020\n\010platform\030\010 \001(\005"
  "\022E\n\013inventories\030\t \003(\01320.CUserMessage_Inv"
  "entory_Response.InventoryDetail\022F\n\014inven"
  "tories2\030\n \003(\01320.CUserMessage_Inventory_R"
  "esponse.InventoryDetail\022F\n\014inventories3\030"
  "\016 \003(\01320.CUserMessage_Inventory_Response."
  "InventoryDetail\022\020\n\010inv_type\030\013 \001(\005\022\025\n\rbui"
  "ld_version\030\014 \001(\005\022\020\n\010instance\030\r \001(\005\022\022\n\nst"
  "art_time\030\017 \001(\003\032\272\001\n\017InventoryDetail\022\r\n\005in"
  "dex\030\001 \001(\005\022\017\n\007primary\030\002 \001(\003\022\016\n\006offset\030\003 \001"
  "(\003\022\r\n\005first\030\004 \001(\003\022\014\n\004base\030\005 \001(\003\022\014\n\004name\030"
  "\006 \001(\t\022\021\n\tbase_name\030\007 \001(\t\022\023\n\013base_detail\030"
  "\010 \001(\005\022\021\n\tbase_time\030\t \001(\005\022\021\n\tbase_hash\030\n "
  "\001(\005"
  ;
static ::_pbi::once_flag descriptor_table_protobufs_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_protobufs_2eproto = {
    false, false, 2443, descriptor_table_protodef_protobufs_2eproto,
    "protobufs.proto",
    &descriptor_table_protobufs_2eproto_once, nullptr, 0, 10,
    schemas, file_default_instances, TableStruct_protobufs_2eproto::offsets,
    file_level_metadata_protobufs_2eproto, file_level_enum_descriptors_protobufs_2eproto,
    file_level_service_descriptors_protobufs_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_protobufs_2eproto_getter() {
  return &descriptor_table_protobufs_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_protobufs_2eproto(&descriptor_table_protobufs_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CSGOUserCmdPB_EWeaponDecision_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_protobufs_2eproto);
  return file_level_enum_descriptors_protobufs_2eproto[0];
}
bool CSGOUserCmdPB_EWeaponDecision_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CSGOUserCmdPB_EWeaponDecision CSGOUserCmdPB::k_eNone;
constexpr CSGOUserCmdPB_EWeaponDecision CSGOUserCmdPB::k_ePrimaryAttack;
constexpr CSGOUserCmdPB_EWeaponDecision CSGOUserCmdPB::k_eSecondaryAttack;
constexpr CSGOUserCmdPB_EWeaponDecision CSGOUserCmdPB::k_eZoom;
constexpr CSGOUserCmdPB_EWeaponDecision CSGOUserCmdPB::k_eReload;
constexpr CSGOUserCmdPB_EWeaponDecision CSGOUserCmdPB::EWeaponDecision_MIN;
constexpr CSGOUserCmdPB_EWeaponDecision CSGOUserCmdPB::EWeaponDecision_MAX;
constexpr int CSGOUserCmdPB::EWeaponDecision_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class CMsgVector::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgVector>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_w(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgVector::CMsgVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgVector)
}
CMsgVector::CMsgVector(const CMsgVector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgVector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.w_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.w_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  // @@protoc_insertion_point(copy_constructor:CMsgVector)
}

inline void CMsgVector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.w_){0}
  };
}

CMsgVector::~CMsgVector() {
  // @@protoc_insertion_point(destructor:CMsgVector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgVector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgVector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgVector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.w_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgVector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float w = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_w(&has_bits);
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgVector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgVector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // optional float z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  // optional float w = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgVector)
  return target;
}

size_t CMsgVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgVector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float w = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgVector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgVector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgVector::GetClassData() const { return &_class_data_; }


void CMsgVector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgVector*>(&to_msg);
  auto& from = static_cast<const CMsgVector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgVector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.w_ = from._impl_.w_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgVector::CopyFrom(const CMsgVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgVector::IsInitialized() const {
  return true;
}

void CMsgVector::InternalSwap(CMsgVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgVector, _impl_.w_)
      + sizeof(CMsgVector::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(CMsgVector, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgVector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protobufs_2eproto_getter, &descriptor_table_protobufs_2eproto_once,
      file_level_metadata_protobufs_2eproto[0]);
}

// ===================================================================

class CMsgQAngle::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgQAngle>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgQAngle::CMsgQAngle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgQAngle)
}
CMsgQAngle::CMsgQAngle(const CMsgQAngle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgQAngle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:CMsgQAngle)
}

inline void CMsgQAngle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
  };
}

CMsgQAngle::~CMsgQAngle() {
  // @@protoc_insertion_point(destructor:CMsgQAngle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgQAngle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgQAngle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgQAngle::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgQAngle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgQAngle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgQAngle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgQAngle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // optional float z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgQAngle)
  return target;
}

size_t CMsgQAngle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgQAngle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgQAngle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgQAngle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgQAngle::GetClassData() const { return &_class_data_; }


void CMsgQAngle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgQAngle*>(&to_msg);
  auto& from = static_cast<const CMsgQAngle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgQAngle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgQAngle::CopyFrom(const CMsgQAngle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgQAngle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgQAngle::IsInitialized() const {
  return true;
}

void CMsgQAngle::InternalSwap(CMsgQAngle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgQAngle, _impl_.z_)
      + sizeof(CMsgQAngle::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(CMsgQAngle, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgQAngle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protobufs_2eproto_getter, &descriptor_table_protobufs_2eproto_once,
      file_level_metadata_protobufs_2eproto[1]);
}

// ===================================================================

class CInButtonStatePB::_Internal {
 public:
  using HasBits = decltype(std::declval<CInButtonStatePB>()._impl_._has_bits_);
  static void set_has_buttonstate1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_buttonstate2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_buttonstate3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CInButtonStatePB::CInButtonStatePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CInButtonStatePB)
}
CInButtonStatePB::CInButtonStatePB(const CInButtonStatePB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CInButtonStatePB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buttonstate1_){}
    , decltype(_impl_.buttonstate2_){}
    , decltype(_impl_.buttonstate3_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.buttonstate1_, &from._impl_.buttonstate1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.buttonstate3_) -
    reinterpret_cast<char*>(&_impl_.buttonstate1_)) + sizeof(_impl_.buttonstate3_));
  // @@protoc_insertion_point(copy_constructor:CInButtonStatePB)
}

inline void CInButtonStatePB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buttonstate1_){uint64_t{0u}}
    , decltype(_impl_.buttonstate2_){uint64_t{0u}}
    , decltype(_impl_.buttonstate3_){uint64_t{0u}}
  };
}

CInButtonStatePB::~CInButtonStatePB() {
  // @@protoc_insertion_point(destructor:CInButtonStatePB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CInButtonStatePB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInButtonStatePB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CInButtonStatePB::Clear() {
// @@protoc_insertion_point(message_clear_start:CInButtonStatePB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.buttonstate1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.buttonstate3_) -
        reinterpret_cast<char*>(&_impl_.buttonstate1_)) + sizeof(_impl_.buttonstate3_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInButtonStatePB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 buttonstate1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_buttonstate1(&has_bits);
          _impl_.buttonstate1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 buttonstate2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_buttonstate2(&has_bits);
          _impl_.buttonstate2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 buttonstate3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_buttonstate3(&has_bits);
          _impl_.buttonstate3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInButtonStatePB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInButtonStatePB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 buttonstate1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_buttonstate1(), target);
  }

  // optional uint64 buttonstate2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_buttonstate2(), target);
  }

  // optional uint64 buttonstate3 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_buttonstate3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInButtonStatePB)
  return target;
}

size_t CInButtonStatePB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInButtonStatePB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 buttonstate1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_buttonstate1());
    }

    // optional uint64 buttonstate2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_buttonstate2());
    }

    // optional uint64 buttonstate3 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_buttonstate3());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInButtonStatePB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CInButtonStatePB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInButtonStatePB::GetClassData() const { return &_class_data_; }


void CInButtonStatePB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CInButtonStatePB*>(&to_msg);
  auto& from = static_cast<const CInButtonStatePB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CInButtonStatePB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.buttonstate1_ = from._impl_.buttonstate1_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.buttonstate2_ = from._impl_.buttonstate2_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.buttonstate3_ = from._impl_.buttonstate3_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInButtonStatePB::CopyFrom(const CInButtonStatePB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInButtonStatePB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInButtonStatePB::IsInitialized() const {
  return true;
}

void CInButtonStatePB::InternalSwap(CInButtonStatePB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CInButtonStatePB, _impl_.buttonstate3_)
      + sizeof(CInButtonStatePB::_impl_.buttonstate3_)
      - PROTOBUF_FIELD_OFFSET(CInButtonStatePB, _impl_.buttonstate1_)>(
          reinterpret_cast<char*>(&_impl_.buttonstate1_),
          reinterpret_cast<char*>(&other->_impl_.buttonstate1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CInButtonStatePB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protobufs_2eproto_getter, &descriptor_table_protobufs_2eproto_once,
      file_level_metadata_protobufs_2eproto[2]);
}

// ===================================================================

class CSubtickMoveStep::_Internal {
 public:
  using HasBits = decltype(std::declval<CSubtickMoveStep>()._impl_._has_bits_);
  static void set_has_button(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pressed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_when(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSubtickMoveStep::CSubtickMoveStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSubtickMoveStep)
}
CSubtickMoveStep::CSubtickMoveStep(const CSubtickMoveStep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSubtickMoveStep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.button_){}
    , decltype(_impl_.pressed_){}
    , decltype(_impl_.when_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.button_, &from._impl_.button_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.when_) -
    reinterpret_cast<char*>(&_impl_.button_)) + sizeof(_impl_.when_));
  // @@protoc_insertion_point(copy_constructor:CSubtickMoveStep)
}

inline void CSubtickMoveStep::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.button_){uint64_t{0u}}
    , decltype(_impl_.pressed_){false}
    , decltype(_impl_.when_){0}
  };
}

CSubtickMoveStep::~CSubtickMoveStep() {
  // @@protoc_insertion_point(destructor:CSubtickMoveStep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSubtickMoveStep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSubtickMoveStep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSubtickMoveStep::Clear() {
// @@protoc_insertion_point(message_clear_start:CSubtickMoveStep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.button_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.when_) -
        reinterpret_cast<char*>(&_impl_.button_)) + sizeof(_impl_.when_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSubtickMoveStep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 button = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_button(&has_bits);
          _impl_.button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool pressed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pressed(&has_bits);
          _impl_.pressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float when = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_when(&has_bits);
          _impl_.when_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSubtickMoveStep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSubtickMoveStep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 button = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_button(), target);
  }

  // optional bool pressed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_pressed(), target);
  }

  // optional float when = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_when(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSubtickMoveStep)
  return target;
}

size_t CSubtickMoveStep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSubtickMoveStep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 button = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_button());
    }

    // optional bool pressed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional float when = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSubtickMoveStep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSubtickMoveStep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSubtickMoveStep::GetClassData() const { return &_class_data_; }


void CSubtickMoveStep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSubtickMoveStep*>(&to_msg);
  auto& from = static_cast<const CSubtickMoveStep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSubtickMoveStep)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.button_ = from._impl_.button_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pressed_ = from._impl_.pressed_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.when_ = from._impl_.when_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSubtickMoveStep::CopyFrom(const CSubtickMoveStep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSubtickMoveStep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSubtickMoveStep::IsInitialized() const {
  return true;
}

void CSubtickMoveStep::InternalSwap(CSubtickMoveStep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSubtickMoveStep, _impl_.when_)
      + sizeof(CSubtickMoveStep::_impl_.when_)
      - PROTOBUF_FIELD_OFFSET(CSubtickMoveStep, _impl_.button_)>(
          reinterpret_cast<char*>(&_impl_.button_),
          reinterpret_cast<char*>(&other->_impl_.button_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSubtickMoveStep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protobufs_2eproto_getter, &descriptor_table_protobufs_2eproto_once,
      file_level_metadata_protobufs_2eproto[3]);
}

// ===================================================================

class CBaseUserCmdPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CBaseUserCmdPB>()._impl_._has_bits_);
  static void set_has_command_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tick_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CInButtonStatePB& buttons_pb(const CBaseUserCmdPB* msg);
  static void set_has_buttons_pb(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgQAngle& viewangles(const CBaseUserCmdPB* msg);
  static void set_has_viewangles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_forwardmove(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_leftmove(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_upmove(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_impulse(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_weaponselect(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_random_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_mousedx(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_mousedy(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_pawn_entity_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_move_crc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_consumed_server_angle_changes(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_cmd_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::CInButtonStatePB&
CBaseUserCmdPB::_Internal::buttons_pb(const CBaseUserCmdPB* msg) {
  return *msg->_impl_.buttons_pb_;
}
const ::CMsgQAngle&
CBaseUserCmdPB::_Internal::viewangles(const CBaseUserCmdPB* msg) {
  return *msg->_impl_.viewangles_;
}
CBaseUserCmdPB::CBaseUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CBaseUserCmdPB)
}
CBaseUserCmdPB::CBaseUserCmdPB(const CBaseUserCmdPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CBaseUserCmdPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subtick_moves_){from._impl_.subtick_moves_}
    , decltype(_impl_.move_crc_){}
    , decltype(_impl_.buttons_pb_){nullptr}
    , decltype(_impl_.viewangles_){nullptr}
    , decltype(_impl_.command_number_){}
    , decltype(_impl_.tick_count_){}
    , decltype(_impl_.forwardmove_){}
    , decltype(_impl_.leftmove_){}
    , decltype(_impl_.upmove_){}
    , decltype(_impl_.impulse_){}
    , decltype(_impl_.weaponselect_){}
    , decltype(_impl_.random_seed_){}
    , decltype(_impl_.mousedx_){}
    , decltype(_impl_.mousedy_){}
    , decltype(_impl_.consumed_server_angle_changes_){}
    , decltype(_impl_.cmd_flags_){}
    , decltype(_impl_.pawn_entity_handle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.move_crc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.move_crc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_move_crc()) {
    _this->_impl_.move_crc_.Set(from._internal_move_crc(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_buttons_pb()) {
    _this->_impl_.buttons_pb_ = new ::CInButtonStatePB(*from._impl_.buttons_pb_);
  }
  if (from._internal_has_viewangles()) {
    _this->_impl_.viewangles_ = new ::CMsgQAngle(*from._impl_.viewangles_);
  }
  ::memcpy(&_impl_.command_number_, &from._impl_.command_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pawn_entity_handle_) -
    reinterpret_cast<char*>(&_impl_.command_number_)) + sizeof(_impl_.pawn_entity_handle_));
  // @@protoc_insertion_point(copy_constructor:CBaseUserCmdPB)
}

inline void CBaseUserCmdPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subtick_moves_){arena}
    , decltype(_impl_.move_crc_){}
    , decltype(_impl_.buttons_pb_){nullptr}
    , decltype(_impl_.viewangles_){nullptr}
    , decltype(_impl_.command_number_){0}
    , decltype(_impl_.tick_count_){0}
    , decltype(_impl_.forwardmove_){0}
    , decltype(_impl_.leftmove_){0}
    , decltype(_impl_.upmove_){0}
    , decltype(_impl_.impulse_){0}
    , decltype(_impl_.weaponselect_){0}
    , decltype(_impl_.random_seed_){0}
    , decltype(_impl_.mousedx_){0}
    , decltype(_impl_.mousedy_){0}
    , decltype(_impl_.consumed_server_angle_changes_){0u}
    , decltype(_impl_.cmd_flags_){0}
    , decltype(_impl_.pawn_entity_handle_){16777215u}
  };
  _impl_.move_crc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.move_crc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CBaseUserCmdPB::~CBaseUserCmdPB() {
  // @@protoc_insertion_point(destructor:CBaseUserCmdPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CBaseUserCmdPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subtick_moves_.~RepeatedPtrField();
  _impl_.move_crc_.Destroy();
  if (this != internal_default_instance()) delete _impl_.buttons_pb_;
  if (this != internal_default_instance()) delete _impl_.viewangles_;
}

void CBaseUserCmdPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CBaseUserCmdPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CBaseUserCmdPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subtick_moves_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.move_crc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.buttons_pb_ != nullptr);
      _impl_.buttons_pb_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.viewangles_ != nullptr);
      _impl_.viewangles_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.command_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.upmove_) -
        reinterpret_cast<char*>(&_impl_.command_number_)) + sizeof(_impl_.upmove_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.impulse_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cmd_flags_) -
        reinterpret_cast<char*>(&_impl_.impulse_)) + sizeof(_impl_.cmd_flags_));
    _impl_.pawn_entity_handle_ = 16777215u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CBaseUserCmdPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 command_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_command_number(&has_bits);
          _impl_.command_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tick_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tick_count(&has_bits);
          _impl_.tick_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CInButtonStatePB buttons_pb = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_buttons_pb(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle viewangles = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_viewangles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float forwardmove = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_forwardmove(&has_bits);
          _impl_.forwardmove_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float leftmove = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_leftmove(&has_bits);
          _impl_.leftmove_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float upmove = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_upmove(&has_bits);
          _impl_.upmove_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 impulse = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_impulse(&has_bits);
          _impl_.impulse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 weaponselect = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_weaponselect(&has_bits);
          _impl_.weaponselect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 random_seed = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_random_seed(&has_bits);
          _impl_.random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mousedx = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_mousedx(&has_bits);
          _impl_.mousedx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mousedy = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_mousedy(&has_bits);
          _impl_.mousedy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pawn_entity_handle = 14 [default = 16777215];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_pawn_entity_handle(&has_bits);
          _impl_.pawn_entity_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSubtickMoveStep subtick_moves = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_subtick_moves(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes move_crc = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_move_crc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 consumed_server_angle_changes = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_consumed_server_angle_changes(&has_bits);
          _impl_.consumed_server_angle_changes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cmd_flags = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_cmd_flags(&has_bits);
          _impl_.cmd_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CBaseUserCmdPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CBaseUserCmdPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 command_number = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_command_number(), target);
  }

  // optional int32 tick_count = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_tick_count(), target);
  }

  // optional .CInButtonStatePB buttons_pb = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::buttons_pb(this),
        _Internal::buttons_pb(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle viewangles = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::viewangles(this),
        _Internal::viewangles(this).GetCachedSize(), target, stream);
  }

  // optional float forwardmove = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_forwardmove(), target);
  }

  // optional float leftmove = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_leftmove(), target);
  }

  // optional float upmove = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_upmove(), target);
  }

  // optional int32 impulse = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_impulse(), target);
  }

  // optional int32 weaponselect = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_weaponselect(), target);
  }

  // optional int32 random_seed = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_random_seed(), target);
  }

  // optional int32 mousedx = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_mousedx(), target);
  }

  // optional int32 mousedy = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_mousedy(), target);
  }

  // optional uint32 pawn_entity_handle = 14 [default = 16777215];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_pawn_entity_handle(), target);
  }

  // repeated .CSubtickMoveStep subtick_moves = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subtick_moves_size()); i < n; i++) {
    const auto& repfield = this->_internal_subtick_moves(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes move_crc = 19;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        19, this->_internal_move_crc(), target);
  }

  // optional uint32 consumed_server_angle_changes = 20;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_consumed_server_angle_changes(), target);
  }

  // optional int32 cmd_flags = 21;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(21, this->_internal_cmd_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CBaseUserCmdPB)
  return target;
}

size_t CBaseUserCmdPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CBaseUserCmdPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSubtickMoveStep subtick_moves = 18;
  total_size += 2UL * this->_internal_subtick_moves_size();
  for (const auto& msg : this->_impl_.subtick_moves_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes move_crc = 19;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_move_crc());
    }

    // optional .CInButtonStatePB buttons_pb = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.buttons_pb_);
    }

    // optional .CMsgQAngle viewangles = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.viewangles_);
    }

    // optional int32 command_number = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_command_number());
    }

    // optional int32 tick_count = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tick_count());
    }

    // optional float forwardmove = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float leftmove = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float upmove = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 impulse = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_impulse());
    }

    // optional int32 weaponselect = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_weaponselect());
    }

    // optional int32 random_seed = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_random_seed());
    }

    // optional int32 mousedx = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mousedx());
    }

    // optional int32 mousedy = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mousedy());
    }

    // optional uint32 consumed_server_angle_changes = 20;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_consumed_server_angle_changes());
    }

    // optional int32 cmd_flags = 21;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_cmd_flags());
    }

    // optional uint32 pawn_entity_handle = 14 [default = 16777215];
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pawn_entity_handle());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CBaseUserCmdPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CBaseUserCmdPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CBaseUserCmdPB::GetClassData() const { return &_class_data_; }


void CBaseUserCmdPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CBaseUserCmdPB*>(&to_msg);
  auto& from = static_cast<const CBaseUserCmdPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CBaseUserCmdPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subtick_moves_.MergeFrom(from._impl_.subtick_moves_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_move_crc(from._internal_move_crc());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_buttons_pb()->::CInButtonStatePB::MergeFrom(
          from._internal_buttons_pb());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_viewangles()->::CMsgQAngle::MergeFrom(
          from._internal_viewangles());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.command_number_ = from._impl_.command_number_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tick_count_ = from._impl_.tick_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.forwardmove_ = from._impl_.forwardmove_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.leftmove_ = from._impl_.leftmove_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.upmove_ = from._impl_.upmove_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.impulse_ = from._impl_.impulse_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.weaponselect_ = from._impl_.weaponselect_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.random_seed_ = from._impl_.random_seed_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.mousedx_ = from._impl_.mousedx_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.mousedy_ = from._impl_.mousedy_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.consumed_server_angle_changes_ = from._impl_.consumed_server_angle_changes_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.cmd_flags_ = from._impl_.cmd_flags_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.pawn_entity_handle_ = from._impl_.pawn_entity_handle_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CBaseUserCmdPB::CopyFrom(const CBaseUserCmdPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CBaseUserCmdPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CBaseUserCmdPB::IsInitialized() const {
  return true;
}

void CBaseUserCmdPB::InternalSwap(CBaseUserCmdPB* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.subtick_moves_.InternalSwap(&other->_impl_.subtick_moves_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.move_crc_, lhs_arena,
      &other->_impl_.move_crc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CBaseUserCmdPB, _impl_.cmd_flags_)
      + sizeof(CBaseUserCmdPB::_impl_.cmd_flags_)
      - PROTOBUF_FIELD_OFFSET(CBaseUserCmdPB, _impl_.buttons_pb_)>(
          reinterpret_cast<char*>(&_impl_.buttons_pb_),
          reinterpret_cast<char*>(&other->_impl_.buttons_pb_));
  swap(_impl_.pawn_entity_handle_, other->_impl_.pawn_entity_handle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CBaseUserCmdPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protobufs_2eproto_getter, &descriptor_table_protobufs_2eproto_once,
      file_level_metadata_protobufs_2eproto[4]);
}

// ===================================================================

class CSGOInterpolationInfoPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CSGOInterpolationInfoPB>()._impl_._has_bits_);
  static void set_has_src_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dst_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_frac(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSGOInterpolationInfoPB::CSGOInterpolationInfoPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSGOInterpolationInfoPB)
}
CSGOInterpolationInfoPB::CSGOInterpolationInfoPB(const CSGOInterpolationInfoPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSGOInterpolationInfoPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frac_){}
    , decltype(_impl_.src_tick_){}
    , decltype(_impl_.dst_tick_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.frac_, &from._impl_.frac_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dst_tick_) -
    reinterpret_cast<char*>(&_impl_.frac_)) + sizeof(_impl_.dst_tick_));
  // @@protoc_insertion_point(copy_constructor:CSGOInterpolationInfoPB)
}

inline void CSGOInterpolationInfoPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frac_){0}
    , decltype(_impl_.src_tick_){-1}
    , decltype(_impl_.dst_tick_){-1}
  };
}

CSGOInterpolationInfoPB::~CSGOInterpolationInfoPB() {
  // @@protoc_insertion_point(destructor:CSGOInterpolationInfoPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSGOInterpolationInfoPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSGOInterpolationInfoPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSGOInterpolationInfoPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CSGOInterpolationInfoPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    _impl_.frac_ = 0;
    _impl_.src_tick_ = -1;
    _impl_.dst_tick_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSGOInterpolationInfoPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 src_tick = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_src_tick(&has_bits);
          _impl_.src_tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dst_tick = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_dst_tick(&has_bits);
          _impl_.dst_tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float frac = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_frac(&has_bits);
          _impl_.frac_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSGOInterpolationInfoPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSGOInterpolationInfoPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 src_tick = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_src_tick(), target);
  }

  // optional int32 dst_tick = 2 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_dst_tick(), target);
  }

  // optional float frac = 3 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_frac(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSGOInterpolationInfoPB)
  return target;
}

size_t CSGOInterpolationInfoPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSGOInterpolationInfoPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float frac = 3 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 src_tick = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_src_tick());
    }

    // optional int32 dst_tick = 2 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dst_tick());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSGOInterpolationInfoPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSGOInterpolationInfoPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSGOInterpolationInfoPB::GetClassData() const { return &_class_data_; }


void CSGOInterpolationInfoPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSGOInterpolationInfoPB*>(&to_msg);
  auto& from = static_cast<const CSGOInterpolationInfoPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSGOInterpolationInfoPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.frac_ = from._impl_.frac_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.src_tick_ = from._impl_.src_tick_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.dst_tick_ = from._impl_.dst_tick_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSGOInterpolationInfoPB::CopyFrom(const CSGOInterpolationInfoPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSGOInterpolationInfoPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGOInterpolationInfoPB::IsInitialized() const {
  return true;
}

void CSGOInterpolationInfoPB::InternalSwap(CSGOInterpolationInfoPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.frac_, other->_impl_.frac_);
  swap(_impl_.src_tick_, other->_impl_.src_tick_);
  swap(_impl_.dst_tick_, other->_impl_.dst_tick_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSGOInterpolationInfoPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protobufs_2eproto_getter, &descriptor_table_protobufs_2eproto_once,
      file_level_metadata_protobufs_2eproto[5]);
}

// ===================================================================

class CSGOInputHistoryEntryPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CSGOInputHistoryEntryPB>()._impl_._has_bits_);
  static const ::CMsgQAngle& view_angles(const CSGOInputHistoryEntryPB* msg);
  static void set_has_view_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_render_tick_count(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_render_tick_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_player_tick_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_player_tick_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::CSGOInterpolationInfoPB& cl_interp(const CSGOInputHistoryEntryPB* msg);
  static void set_has_cl_interp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::CSGOInterpolationInfoPB& sv_interp0(const CSGOInputHistoryEntryPB* msg);
  static void set_has_sv_interp0(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::CSGOInterpolationInfoPB& sv_interp1(const CSGOInputHistoryEntryPB* msg);
  static void set_has_sv_interp1(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::CSGOInterpolationInfoPB& player_interp(const CSGOInputHistoryEntryPB* msg);
  static void set_has_player_interp(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_frame_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_target_ent_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::CMsgVector& shoot_position(const CSGOInputHistoryEntryPB* msg);
  static void set_has_shoot_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& target_head_pos_check(const CSGOInputHistoryEntryPB* msg);
  static void set_has_target_head_pos_check(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgVector& target_abs_pos_check(const CSGOInputHistoryEntryPB* msg);
  static void set_has_target_abs_pos_check(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgQAngle& target_abs_ang_check(const CSGOInputHistoryEntryPB* msg);
  static void set_has_target_abs_ang_check(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgQAngle&
CSGOInputHistoryEntryPB::_Internal::view_angles(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.view_angles_;
}
const ::CSGOInterpolationInfoPB&
CSGOInputHistoryEntryPB::_Internal::cl_interp(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.cl_interp_;
}
const ::CSGOInterpolationInfoPB&
CSGOInputHistoryEntryPB::_Internal::sv_interp0(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.sv_interp0_;
}
const ::CSGOInterpolationInfoPB&
CSGOInputHistoryEntryPB::_Internal::sv_interp1(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.sv_interp1_;
}
const ::CSGOInterpolationInfoPB&
CSGOInputHistoryEntryPB::_Internal::player_interp(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.player_interp_;
}
const ::CMsgVector&
CSGOInputHistoryEntryPB::_Internal::shoot_position(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.shoot_position_;
}
const ::CMsgVector&
CSGOInputHistoryEntryPB::_Internal::target_head_pos_check(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.target_head_pos_check_;
}
const ::CMsgVector&
CSGOInputHistoryEntryPB::_Internal::target_abs_pos_check(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.target_abs_pos_check_;
}
const ::CMsgQAngle&
CSGOInputHistoryEntryPB::_Internal::target_abs_ang_check(const CSGOInputHistoryEntryPB* msg) {
  return *msg->_impl_.target_abs_ang_check_;
}
CSGOInputHistoryEntryPB::CSGOInputHistoryEntryPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSGOInputHistoryEntryPB)
}
CSGOInputHistoryEntryPB::CSGOInputHistoryEntryPB(const CSGOInputHistoryEntryPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSGOInputHistoryEntryPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.view_angles_){nullptr}
    , decltype(_impl_.shoot_position_){nullptr}
    , decltype(_impl_.target_head_pos_check_){nullptr}
    , decltype(_impl_.target_abs_pos_check_){nullptr}
    , decltype(_impl_.target_abs_ang_check_){nullptr}
    , decltype(_impl_.cl_interp_){nullptr}
    , decltype(_impl_.sv_interp0_){nullptr}
    , decltype(_impl_.sv_interp1_){nullptr}
    , decltype(_impl_.player_interp_){nullptr}
    , decltype(_impl_.render_tick_count_){}
    , decltype(_impl_.render_tick_fraction_){}
    , decltype(_impl_.player_tick_count_){}
    , decltype(_impl_.player_tick_fraction_){}
    , decltype(_impl_.frame_number_){}
    , decltype(_impl_.target_ent_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_view_angles()) {
    _this->_impl_.view_angles_ = new ::CMsgQAngle(*from._impl_.view_angles_);
  }
  if (from._internal_has_shoot_position()) {
    _this->_impl_.shoot_position_ = new ::CMsgVector(*from._impl_.shoot_position_);
  }
  if (from._internal_has_target_head_pos_check()) {
    _this->_impl_.target_head_pos_check_ = new ::CMsgVector(*from._impl_.target_head_pos_check_);
  }
  if (from._internal_has_target_abs_pos_check()) {
    _this->_impl_.target_abs_pos_check_ = new ::CMsgVector(*from._impl_.target_abs_pos_check_);
  }
  if (from._internal_has_target_abs_ang_check()) {
    _this->_impl_.target_abs_ang_check_ = new ::CMsgQAngle(*from._impl_.target_abs_ang_check_);
  }
  if (from._internal_has_cl_interp()) {
    _this->_impl_.cl_interp_ = new ::CSGOInterpolationInfoPB(*from._impl_.cl_interp_);
  }
  if (from._internal_has_sv_interp0()) {
    _this->_impl_.sv_interp0_ = new ::CSGOInterpolationInfoPB(*from._impl_.sv_interp0_);
  }
  if (from._internal_has_sv_interp1()) {
    _this->_impl_.sv_interp1_ = new ::CSGOInterpolationInfoPB(*from._impl_.sv_interp1_);
  }
  if (from._internal_has_player_interp()) {
    _this->_impl_.player_interp_ = new ::CSGOInterpolationInfoPB(*from._impl_.player_interp_);
  }
  ::memcpy(&_impl_.render_tick_count_, &from._impl_.render_tick_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_ent_index_) -
    reinterpret_cast<char*>(&_impl_.render_tick_count_)) + sizeof(_impl_.target_ent_index_));
  // @@protoc_insertion_point(copy_constructor:CSGOInputHistoryEntryPB)
}

inline void CSGOInputHistoryEntryPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.view_angles_){nullptr}
    , decltype(_impl_.shoot_position_){nullptr}
    , decltype(_impl_.target_head_pos_check_){nullptr}
    , decltype(_impl_.target_abs_pos_check_){nullptr}
    , decltype(_impl_.target_abs_ang_check_){nullptr}
    , decltype(_impl_.cl_interp_){nullptr}
    , decltype(_impl_.sv_interp0_){nullptr}
    , decltype(_impl_.sv_interp1_){nullptr}
    , decltype(_impl_.player_interp_){nullptr}
    , decltype(_impl_.render_tick_count_){0}
    , decltype(_impl_.render_tick_fraction_){0}
    , decltype(_impl_.player_tick_count_){0}
    , decltype(_impl_.player_tick_fraction_){0}
    , decltype(_impl_.frame_number_){0}
    , decltype(_impl_.target_ent_index_){-1}
  };
}

CSGOInputHistoryEntryPB::~CSGOInputHistoryEntryPB() {
  // @@protoc_insertion_point(destructor:CSGOInputHistoryEntryPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSGOInputHistoryEntryPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.view_angles_;
  if (this != internal_default_instance()) delete _impl_.shoot_position_;
  if (this != internal_default_instance()) delete _impl_.target_head_pos_check_;
  if (this != internal_default_instance()) delete _impl_.target_abs_pos_check_;
  if (this != internal_default_instance()) delete _impl_.target_abs_ang_check_;
  if (this != internal_default_instance()) delete _impl_.cl_interp_;
  if (this != internal_default_instance()) delete _impl_.sv_interp0_;
  if (this != internal_default_instance()) delete _impl_.sv_interp1_;
  if (this != internal_default_instance()) delete _impl_.player_interp_;
}

void CSGOInputHistoryEntryPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSGOInputHistoryEntryPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CSGOInputHistoryEntryPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.view_angles_ != nullptr);
      _impl_.view_angles_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.shoot_position_ != nullptr);
      _impl_.shoot_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.target_head_pos_check_ != nullptr);
      _impl_.target_head_pos_check_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.target_abs_pos_check_ != nullptr);
      _impl_.target_abs_pos_check_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.target_abs_ang_check_ != nullptr);
      _impl_.target_abs_ang_check_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.cl_interp_ != nullptr);
      _impl_.cl_interp_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.sv_interp0_ != nullptr);
      _impl_.sv_interp0_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.sv_interp1_ != nullptr);
      _impl_.sv_interp1_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(_impl_.player_interp_ != nullptr);
    _impl_.player_interp_->Clear();
  }
  if (cached_has_bits & 0x00007e00u) {
    ::memset(&_impl_.render_tick_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.frame_number_) -
        reinterpret_cast<char*>(&_impl_.render_tick_count_)) + sizeof(_impl_.frame_number_));
    _impl_.target_ent_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSGOInputHistoryEntryPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgQAngle view_angles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_view_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector shoot_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_shoot_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 render_tick_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_render_tick_count(&has_bits);
          _impl_.render_tick_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float render_tick_fraction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_render_tick_fraction(&has_bits);
          _impl_.render_tick_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_tick_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_player_tick_count(&has_bits);
          _impl_.player_tick_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float player_tick_fraction = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_player_tick_fraction(&has_bits);
          _impl_.player_tick_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_ent_index = 8 [default = -1];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_target_ent_index(&has_bits);
          _impl_.target_ent_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector target_head_pos_check = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_head_pos_check(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector target_abs_pos_check = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_abs_pos_check(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle target_abs_ang_check = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_abs_ang_check(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CSGOInterpolationInfoPB cl_interp = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_cl_interp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CSGOInterpolationInfoPB sv_interp0 = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_sv_interp0(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CSGOInterpolationInfoPB sv_interp1 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_sv_interp1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CSGOInterpolationInfoPB player_interp = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_interp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 frame_number = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_frame_number(&has_bits);
          _impl_.frame_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSGOInputHistoryEntryPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSGOInputHistoryEntryPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgQAngle view_angles = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::view_angles(this),
        _Internal::view_angles(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector shoot_position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::shoot_position(this),
        _Internal::shoot_position(this).GetCachedSize(), target, stream);
  }

  // optional int32 render_tick_count = 4;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_render_tick_count(), target);
  }

  // optional float render_tick_fraction = 5;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_render_tick_fraction(), target);
  }

  // optional int32 player_tick_count = 6;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_player_tick_count(), target);
  }

  // optional float player_tick_fraction = 7;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_player_tick_fraction(), target);
  }

  // optional int32 target_ent_index = 8 [default = -1];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_target_ent_index(), target);
  }

  // optional .CMsgVector target_head_pos_check = 9;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::target_head_pos_check(this),
        _Internal::target_head_pos_check(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector target_abs_pos_check = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::target_abs_pos_check(this),
        _Internal::target_abs_pos_check(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle target_abs_ang_check = 11;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::target_abs_ang_check(this),
        _Internal::target_abs_ang_check(this).GetCachedSize(), target, stream);
  }

  // optional .CSGOInterpolationInfoPB cl_interp = 12;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::cl_interp(this),
        _Internal::cl_interp(this).GetCachedSize(), target, stream);
  }

  // optional .CSGOInterpolationInfoPB sv_interp0 = 13;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::sv_interp0(this),
        _Internal::sv_interp0(this).GetCachedSize(), target, stream);
  }

  // optional .CSGOInterpolationInfoPB sv_interp1 = 14;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::sv_interp1(this),
        _Internal::sv_interp1(this).GetCachedSize(), target, stream);
  }

  // optional .CSGOInterpolationInfoPB player_interp = 15;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::player_interp(this),
        _Internal::player_interp(this).GetCachedSize(), target, stream);
  }

  // optional int32 frame_number = 20;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_frame_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSGOInputHistoryEntryPB)
  return target;
}

size_t CSGOInputHistoryEntryPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSGOInputHistoryEntryPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgQAngle view_angles = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.view_angles_);
    }

    // optional .CMsgVector shoot_position = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shoot_position_);
    }

    // optional .CMsgVector target_head_pos_check = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.target_head_pos_check_);
    }

    // optional .CMsgVector target_abs_pos_check = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.target_abs_pos_check_);
    }

    // optional .CMsgQAngle target_abs_ang_check = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.target_abs_ang_check_);
    }

    // optional .CSGOInterpolationInfoPB cl_interp = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cl_interp_);
    }

    // optional .CSGOInterpolationInfoPB sv_interp0 = 13;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sv_interp0_);
    }

    // optional .CSGOInterpolationInfoPB sv_interp1 = 14;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sv_interp1_);
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional .CSGOInterpolationInfoPB player_interp = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_interp_);
    }

    // optional int32 render_tick_count = 4;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_render_tick_count());
    }

    // optional float render_tick_fraction = 5;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional int32 player_tick_count = 6;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_tick_count());
    }

    // optional float player_tick_fraction = 7;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional int32 frame_number = 20;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_frame_number());
    }

    // optional int32 target_ent_index = 8 [default = -1];
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_ent_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSGOInputHistoryEntryPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSGOInputHistoryEntryPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSGOInputHistoryEntryPB::GetClassData() const { return &_class_data_; }


void CSGOInputHistoryEntryPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSGOInputHistoryEntryPB*>(&to_msg);
  auto& from = static_cast<const CSGOInputHistoryEntryPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSGOInputHistoryEntryPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_view_angles()->::CMsgQAngle::MergeFrom(
          from._internal_view_angles());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_shoot_position()->::CMsgVector::MergeFrom(
          from._internal_shoot_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_target_head_pos_check()->::CMsgVector::MergeFrom(
          from._internal_target_head_pos_check());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_target_abs_pos_check()->::CMsgVector::MergeFrom(
          from._internal_target_abs_pos_check());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_target_abs_ang_check()->::CMsgQAngle::MergeFrom(
          from._internal_target_abs_ang_check());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_cl_interp()->::CSGOInterpolationInfoPB::MergeFrom(
          from._internal_cl_interp());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_sv_interp0()->::CSGOInterpolationInfoPB::MergeFrom(
          from._internal_sv_interp0());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_sv_interp1()->::CSGOInterpolationInfoPB::MergeFrom(
          from._internal_sv_interp1());
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_player_interp()->::CSGOInterpolationInfoPB::MergeFrom(
          from._internal_player_interp());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.render_tick_count_ = from._impl_.render_tick_count_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.render_tick_fraction_ = from._impl_.render_tick_fraction_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.player_tick_count_ = from._impl_.player_tick_count_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.player_tick_fraction_ = from._impl_.player_tick_fraction_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.frame_number_ = from._impl_.frame_number_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.target_ent_index_ = from._impl_.target_ent_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSGOInputHistoryEntryPB::CopyFrom(const CSGOInputHistoryEntryPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSGOInputHistoryEntryPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGOInputHistoryEntryPB::IsInitialized() const {
  return true;
}

void CSGOInputHistoryEntryPB::InternalSwap(CSGOInputHistoryEntryPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSGOInputHistoryEntryPB, _impl_.frame_number_)
      + sizeof(CSGOInputHistoryEntryPB::_impl_.frame_number_)
      - PROTOBUF_FIELD_OFFSET(CSGOInputHistoryEntryPB, _impl_.view_angles_)>(
          reinterpret_cast<char*>(&_impl_.view_angles_),
          reinterpret_cast<char*>(&other->_impl_.view_angles_));
  swap(_impl_.target_ent_index_, other->_impl_.target_ent_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSGOInputHistoryEntryPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protobufs_2eproto_getter, &descriptor_table_protobufs_2eproto_once,
      file_level_metadata_protobufs_2eproto[6]);
}

// ===================================================================

class CSGOUserCmdPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CSGOUserCmdPB>()._impl_._has_bits_);
  static const ::CBaseUserCmdPB& base(const CSGOUserCmdPB* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attack1_start_history_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_attack2_start_history_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_attack3_start_history_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_weapon_decision(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_weapon_decision_weapon(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CBaseUserCmdPB&
CSGOUserCmdPB::_Internal::base(const CSGOUserCmdPB* msg) {
  return *msg->_impl_.base_;
}
CSGOUserCmdPB::CSGOUserCmdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSGOUserCmdPB)
}
CSGOUserCmdPB::CSGOUserCmdPB(const CSGOUserCmdPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSGOUserCmdPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.input_history_){from._impl_.input_history_}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.weapon_decision_){}
    , decltype(_impl_.weapon_decision_weapon_){}
    , decltype(_impl_.attack3_start_history_index_){}
    , decltype(_impl_.attack1_start_history_index_){}
    , decltype(_impl_.attack2_start_history_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CBaseUserCmdPB(*from._impl_.base_);
  }
  ::memcpy(&_impl_.weapon_decision_, &from._impl_.weapon_decision_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.attack2_start_history_index_) -
    reinterpret_cast<char*>(&_impl_.weapon_decision_)) + sizeof(_impl_.attack2_start_history_index_));
  // @@protoc_insertion_point(copy_constructor:CSGOUserCmdPB)
}

inline void CSGOUserCmdPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.input_history_){arena}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.weapon_decision_){0}
    , decltype(_impl_.weapon_decision_weapon_){0}
    , decltype(_impl_.attack3_start_history_index_){-1}
    , decltype(_impl_.attack1_start_history_index_){-1}
    , decltype(_impl_.attack2_start_history_index_){-1}
  };
}

CSGOUserCmdPB::~CSGOUserCmdPB() {
  // @@protoc_insertion_point(destructor:CSGOUserCmdPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSGOUserCmdPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_history_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.base_;
}

void CSGOUserCmdPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSGOUserCmdPB::Clear() {
// @@protoc_insertion_point(message_clear_start:CSGOUserCmdPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_history_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.base_ != nullptr);
    _impl_.base_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.weapon_decision_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.weapon_decision_weapon_) -
        reinterpret_cast<char*>(&_impl_.weapon_decision_)) + sizeof(_impl_.weapon_decision_weapon_));
    _impl_.attack3_start_history_index_ = -1;
    _impl_.attack1_start_history_index_ = -1;
    _impl_.attack2_start_history_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSGOUserCmdPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CBaseUserCmdPB base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSGOInputHistoryEntryPB input_history = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input_history(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 attack1_start_history_index = 6 [default = -1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_attack1_start_history_index(&has_bits);
          _impl_.attack1_start_history_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 attack2_start_history_index = 7 [default = -1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_attack2_start_history_index(&has_bits);
          _impl_.attack2_start_history_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 attack3_start_history_index = 8 [default = -1];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_attack3_start_history_index(&has_bits);
          _impl_.attack3_start_history_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CSGOUserCmdPB.EWeaponDecision weapon_decision = 9 [default = k_eNone];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CSGOUserCmdPB_EWeaponDecision_IsValid(val))) {
            _internal_set_weapon_decision(static_cast<::CSGOUserCmdPB_EWeaponDecision>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 weapon_decision_weapon = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_weapon_decision_weapon(&has_bits);
          _impl_.weapon_decision_weapon_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSGOUserCmdPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSGOUserCmdPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CBaseUserCmdPB base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // repeated .CSGOInputHistoryEntryPB input_history = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_input_history_size()); i < n; i++) {
    const auto& repfield = this->_internal_input_history(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 attack1_start_history_index = 6 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_attack1_start_history_index(), target);
  }

  // optional int32 attack2_start_history_index = 7 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_attack2_start_history_index(), target);
  }

  // optional int32 attack3_start_history_index = 8 [default = -1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_attack3_start_history_index(), target);
  }

  // optional .CSGOUserCmdPB.EWeaponDecision weapon_decision = 9 [default = k_eNone];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_weapon_decision(), target);
  }

  // optional int32 weapon_decision_weapon = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_weapon_decision_weapon(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSGOUserCmdPB)
  return target;
}

size_t CSGOUserCmdPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSGOUserCmdPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSGOInputHistoryEntryPB input_history = 2;
  total_size += 1UL * this->_internal_input_history_size();
  for (const auto& msg : this->_impl_.input_history_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .CBaseUserCmdPB base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional .CSGOUserCmdPB.EWeaponDecision weapon_decision = 9 [default = k_eNone];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_weapon_decision());
    }

    // optional int32 weapon_decision_weapon = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_weapon_decision_weapon());
    }

    // optional int32 attack3_start_history_index = 8 [default = -1];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attack3_start_history_index());
    }

    // optional int32 attack1_start_history_index = 6 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attack1_start_history_index());
    }

    // optional int32 attack2_start_history_index = 7 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attack2_start_history_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSGOUserCmdPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSGOUserCmdPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSGOUserCmdPB::GetClassData() const { return &_class_data_; }


void CSGOUserCmdPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSGOUserCmdPB*>(&to_msg);
  auto& from = static_cast<const CSGOUserCmdPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSGOUserCmdPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_history_.MergeFrom(from._impl_.input_history_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CBaseUserCmdPB::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.weapon_decision_ = from._impl_.weapon_decision_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.weapon_decision_weapon_ = from._impl_.weapon_decision_weapon_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.attack3_start_history_index_ = from._impl_.attack3_start_history_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.attack1_start_history_index_ = from._impl_.attack1_start_history_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.attack2_start_history_index_ = from._impl_.attack2_start_history_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSGOUserCmdPB::CopyFrom(const CSGOUserCmdPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSGOUserCmdPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSGOUserCmdPB::IsInitialized() const {
  return true;
}

void CSGOUserCmdPB::InternalSwap(CSGOUserCmdPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.input_history_.InternalSwap(&other->_impl_.input_history_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSGOUserCmdPB, _impl_.weapon_decision_weapon_)
      + sizeof(CSGOUserCmdPB::_impl_.weapon_decision_weapon_)
      - PROTOBUF_FIELD_OFFSET(CSGOUserCmdPB, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
  swap(_impl_.attack3_start_history_index_, other->_impl_.attack3_start_history_index_);
  swap(_impl_.attack1_start_history_index_, other->_impl_.attack1_start_history_index_);
  swap(_impl_.attack2_start_history_index_, other->_impl_.attack2_start_history_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSGOUserCmdPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protobufs_2eproto_getter, &descriptor_table_protobufs_2eproto_once,
      file_level_metadata_protobufs_2eproto[7]);
}

// ===================================================================

class CUserMessage_Inventory_Response_InventoryDetail::_Internal {
 public:
  using HasBits = decltype(std::declval<CUserMessage_Inventory_Response_InventoryDetail>()._impl_._has_bits_);
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_primary(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_first(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_base_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_base_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_base_time(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_base_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

CUserMessage_Inventory_Response_InventoryDetail::CUserMessage_Inventory_Response_InventoryDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CUserMessage_Inventory_Response.InventoryDetail)
}
CUserMessage_Inventory_Response_InventoryDetail::CUserMessage_Inventory_Response_InventoryDetail(const CUserMessage_Inventory_Response_InventoryDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CUserMessage_Inventory_Response_InventoryDetail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.base_name_){}
    , decltype(_impl_.primary_){}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.first_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.base_detail_){}
    , decltype(_impl_.base_){}
    , decltype(_impl_.base_time_){}
    , decltype(_impl_.base_hash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.base_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_base_name()) {
    _this->_impl_.base_name_.Set(from._internal_base_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.primary_, &from._impl_.primary_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.base_hash_) -
    reinterpret_cast<char*>(&_impl_.primary_)) + sizeof(_impl_.base_hash_));
  // @@protoc_insertion_point(copy_constructor:CUserMessage_Inventory_Response.InventoryDetail)
}

inline void CUserMessage_Inventory_Response_InventoryDetail::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.base_name_){}
    , decltype(_impl_.primary_){int64_t{0}}
    , decltype(_impl_.offset_){int64_t{0}}
    , decltype(_impl_.first_){int64_t{0}}
    , decltype(_impl_.index_){0}
    , decltype(_impl_.base_detail_){0}
    , decltype(_impl_.base_){int64_t{0}}
    , decltype(_impl_.base_time_){0}
    , decltype(_impl_.base_hash_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CUserMessage_Inventory_Response_InventoryDetail::~CUserMessage_Inventory_Response_InventoryDetail() {
  // @@protoc_insertion_point(destructor:CUserMessage_Inventory_Response.InventoryDetail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CUserMessage_Inventory_Response_InventoryDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.base_name_.Destroy();
}

void CUserMessage_Inventory_Response_InventoryDetail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CUserMessage_Inventory_Response_InventoryDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:CUserMessage_Inventory_Response.InventoryDetail)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.base_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.primary_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.base_) -
        reinterpret_cast<char*>(&_impl_.primary_)) + sizeof(_impl_.base_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.base_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.base_hash_) -
        reinterpret_cast<char*>(&_impl_.base_time_)) + sizeof(_impl_.base_hash_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CUserMessage_Inventory_Response_InventoryDetail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 primary = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_primary(&has_bits);
          _impl_.primary_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 first = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_first(&has_bits);
          _impl_.first_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 base = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_base(&has_bits);
          _impl_.base_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CUserMessage_Inventory_Response.InventoryDetail.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string base_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_base_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CUserMessage_Inventory_Response.InventoryDetail.base_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 base_detail = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_base_detail(&has_bits);
          _impl_.base_detail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 base_time = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_base_time(&has_bits);
          _impl_.base_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 base_hash = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_base_hash(&has_bits);
          _impl_.base_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CUserMessage_Inventory_Response_InventoryDetail::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CUserMessage_Inventory_Response.InventoryDetail)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 index = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_index(), target);
  }

  // optional int64 primary = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_primary(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_offset(), target);
  }

  // optional int64 first = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_first(), target);
  }

  // optional int64 base = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_base(), target);
  }

  // optional string name = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CUserMessage_Inventory_Response.InventoryDetail.name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_name(), target);
  }

  // optional string base_name = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_base_name().data(), static_cast<int>(this->_internal_base_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CUserMessage_Inventory_Response.InventoryDetail.base_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_base_name(), target);
  }

  // optional int32 base_detail = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_base_detail(), target);
  }

  // optional int32 base_time = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_base_time(), target);
  }

  // optional int32 base_hash = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_base_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CUserMessage_Inventory_Response.InventoryDetail)
  return target;
}

size_t CUserMessage_Inventory_Response_InventoryDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CUserMessage_Inventory_Response.InventoryDetail)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string base_name = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_base_name());
    }

    // optional int64 primary = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_primary());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int64 first = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_first());
    }

    // optional int32 index = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_index());
    }

    // optional int32 base_detail = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_base_detail());
    }

    // optional int64 base = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_base());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 base_time = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_base_time());
    }

    // optional int32 base_hash = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_base_hash());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CUserMessage_Inventory_Response_InventoryDetail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CUserMessage_Inventory_Response_InventoryDetail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CUserMessage_Inventory_Response_InventoryDetail::GetClassData() const { return &_class_data_; }


void CUserMessage_Inventory_Response_InventoryDetail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CUserMessage_Inventory_Response_InventoryDetail*>(&to_msg);
  auto& from = static_cast<const CUserMessage_Inventory_Response_InventoryDetail&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CUserMessage_Inventory_Response.InventoryDetail)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_base_name(from._internal_base_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.primary_ = from._impl_.primary_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.first_ = from._impl_.first_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.base_detail_ = from._impl_.base_detail_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.base_ = from._impl_.base_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.base_time_ = from._impl_.base_time_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.base_hash_ = from._impl_.base_hash_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CUserMessage_Inventory_Response_InventoryDetail::CopyFrom(const CUserMessage_Inventory_Response_InventoryDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CUserMessage_Inventory_Response.InventoryDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CUserMessage_Inventory_Response_InventoryDetail::IsInitialized() const {
  return true;
}

void CUserMessage_Inventory_Response_InventoryDetail::InternalSwap(CUserMessage_Inventory_Response_InventoryDetail* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.base_name_, lhs_arena,
      &other->_impl_.base_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CUserMessage_Inventory_Response_InventoryDetail, _impl_.base_hash_)
      + sizeof(CUserMessage_Inventory_Response_InventoryDetail::_impl_.base_hash_)
      - PROTOBUF_FIELD_OFFSET(CUserMessage_Inventory_Response_InventoryDetail, _impl_.primary_)>(
          reinterpret_cast<char*>(&_impl_.primary_),
          reinterpret_cast<char*>(&other->_impl_.primary_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CUserMessage_Inventory_Response_InventoryDetail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protobufs_2eproto_getter, &descriptor_table_protobufs_2eproto_once,
      file_level_metadata_protobufs_2eproto[8]);
}

// ===================================================================

class CUserMessage_Inventory_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CUserMessage_Inventory_Response>()._impl_._has_bits_);
  static void set_has_crc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_osversion(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_perf_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_inv_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_build_version(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_instance(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CUserMessage_Inventory_Response::CUserMessage_Inventory_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CUserMessage_Inventory_Response)
}
CUserMessage_Inventory_Response::CUserMessage_Inventory_Response(const CUserMessage_Inventory_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CUserMessage_Inventory_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.inventories_){from._impl_.inventories_}
    , decltype(_impl_.inventories2_){from._impl_.inventories2_}
    , decltype(_impl_.inventories3_){from._impl_.inventories3_}
    , decltype(_impl_.crc_){}
    , decltype(_impl_.item_count_){}
    , decltype(_impl_.osversion_){}
    , decltype(_impl_.perf_time_){}
    , decltype(_impl_.client_timestamp_){}
    , decltype(_impl_.platform_){}
    , decltype(_impl_.inv_type_){}
    , decltype(_impl_.build_version_){}
    , decltype(_impl_.start_time_){}
    , decltype(_impl_.instance_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.crc_, &from._impl_.crc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.instance_) -
    reinterpret_cast<char*>(&_impl_.crc_)) + sizeof(_impl_.instance_));
  // @@protoc_insertion_point(copy_constructor:CUserMessage_Inventory_Response)
}

inline void CUserMessage_Inventory_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.inventories_){arena}
    , decltype(_impl_.inventories2_){arena}
    , decltype(_impl_.inventories3_){arena}
    , decltype(_impl_.crc_){0u}
    , decltype(_impl_.item_count_){0}
    , decltype(_impl_.osversion_){0}
    , decltype(_impl_.perf_time_){0}
    , decltype(_impl_.client_timestamp_){0}
    , decltype(_impl_.platform_){0}
    , decltype(_impl_.inv_type_){0}
    , decltype(_impl_.build_version_){0}
    , decltype(_impl_.start_time_){int64_t{0}}
    , decltype(_impl_.instance_){0}
  };
}

CUserMessage_Inventory_Response::~CUserMessage_Inventory_Response() {
  // @@protoc_insertion_point(destructor:CUserMessage_Inventory_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CUserMessage_Inventory_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.inventories_.~RepeatedPtrField();
  _impl_.inventories2_.~RepeatedPtrField();
  _impl_.inventories3_.~RepeatedPtrField();
}

void CUserMessage_Inventory_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CUserMessage_Inventory_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CUserMessage_Inventory_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.inventories_.Clear();
  _impl_.inventories2_.Clear();
  _impl_.inventories3_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.crc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.build_version_) -
        reinterpret_cast<char*>(&_impl_.crc_)) + sizeof(_impl_.build_version_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.start_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.instance_) -
        reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.instance_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CUserMessage_Inventory_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 crc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_crc(&has_bits);
          _impl_.crc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_count(&has_bits);
          _impl_.item_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 osversion = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_osversion(&has_bits);
          _impl_.osversion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 perf_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_perf_time(&has_bits);
          _impl_.perf_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 client_timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_client_timestamp(&has_bits);
          _impl_.client_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 platform = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_platform(&has_bits);
          _impl_.platform_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CUserMessage_Inventory_Response.InventoryDetail inventories = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inventories(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CUserMessage_Inventory_Response.InventoryDetail inventories2 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inventories2(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 inv_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_inv_type(&has_bits);
          _impl_.inv_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 build_version = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_build_version(&has_bits);
          _impl_.build_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 instance = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_instance(&has_bits);
          _impl_.instance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CUserMessage_Inventory_Response.InventoryDetail inventories3 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inventories3(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 start_time = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_start_time(&has_bits);
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CUserMessage_Inventory_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CUserMessage_Inventory_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 crc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_crc(), target);
  }

  // optional int32 item_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_item_count(), target);
  }

  // optional int32 osversion = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_osversion(), target);
  }

  // optional int32 perf_time = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_perf_time(), target);
  }

  // optional int32 client_timestamp = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_client_timestamp(), target);
  }

  // optional int32 platform = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_platform(), target);
  }

  // repeated .CUserMessage_Inventory_Response.InventoryDetail inventories = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_inventories_size()); i < n; i++) {
    const auto& repfield = this->_internal_inventories(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CUserMessage_Inventory_Response.InventoryDetail inventories2 = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_inventories2_size()); i < n; i++) {
    const auto& repfield = this->_internal_inventories2(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 inv_type = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_inv_type(), target);
  }

  // optional int32 build_version = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_build_version(), target);
  }

  // optional int32 instance = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_instance(), target);
  }

  // repeated .CUserMessage_Inventory_Response.InventoryDetail inventories3 = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_inventories3_size()); i < n; i++) {
    const auto& repfield = this->_internal_inventories3(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int64 start_time = 15;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(15, this->_internal_start_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CUserMessage_Inventory_Response)
  return target;
}

size_t CUserMessage_Inventory_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CUserMessage_Inventory_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CUserMessage_Inventory_Response.InventoryDetail inventories = 9;
  total_size += 1UL * this->_internal_inventories_size();
  for (const auto& msg : this->_impl_.inventories_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CUserMessage_Inventory_Response.InventoryDetail inventories2 = 10;
  total_size += 1UL * this->_internal_inventories2_size();
  for (const auto& msg : this->_impl_.inventories2_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CUserMessage_Inventory_Response.InventoryDetail inventories3 = 14;
  total_size += 1UL * this->_internal_inventories3_size();
  for (const auto& msg : this->_impl_.inventories3_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional fixed32 crc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 item_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_count());
    }

    // optional int32 osversion = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_osversion());
    }

    // optional int32 perf_time = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_perf_time());
    }

    // optional int32 client_timestamp = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_client_timestamp());
    }

    // optional int32 platform = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_platform());
    }

    // optional int32 inv_type = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_inv_type());
    }

    // optional int32 build_version = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_build_version());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int64 start_time = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_time());
    }

    // optional int32 instance = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_instance());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CUserMessage_Inventory_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CUserMessage_Inventory_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CUserMessage_Inventory_Response::GetClassData() const { return &_class_data_; }


void CUserMessage_Inventory_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CUserMessage_Inventory_Response*>(&to_msg);
  auto& from = static_cast<const CUserMessage_Inventory_Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CUserMessage_Inventory_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.inventories_.MergeFrom(from._impl_.inventories_);
  _this->_impl_.inventories2_.MergeFrom(from._impl_.inventories2_);
  _this->_impl_.inventories3_.MergeFrom(from._impl_.inventories3_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.crc_ = from._impl_.crc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_count_ = from._impl_.item_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.osversion_ = from._impl_.osversion_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.perf_time_ = from._impl_.perf_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.client_timestamp_ = from._impl_.client_timestamp_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.platform_ = from._impl_.platform_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.inv_type_ = from._impl_.inv_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.build_version_ = from._impl_.build_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.start_time_ = from._impl_.start_time_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.instance_ = from._impl_.instance_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CUserMessage_Inventory_Response::CopyFrom(const CUserMessage_Inventory_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CUserMessage_Inventory_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CUserMessage_Inventory_Response::IsInitialized() const {
  return true;
}

void CUserMessage_Inventory_Response::InternalSwap(CUserMessage_Inventory_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.inventories_.InternalSwap(&other->_impl_.inventories_);
  _impl_.inventories2_.InternalSwap(&other->_impl_.inventories2_);
  _impl_.inventories3_.InternalSwap(&other->_impl_.inventories3_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CUserMessage_Inventory_Response, _impl_.instance_)
      + sizeof(CUserMessage_Inventory_Response::_impl_.instance_)
      - PROTOBUF_FIELD_OFFSET(CUserMessage_Inventory_Response, _impl_.crc_)>(
          reinterpret_cast<char*>(&_impl_.crc_),
          reinterpret_cast<char*>(&other->_impl_.crc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CUserMessage_Inventory_Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protobufs_2eproto_getter, &descriptor_table_protobufs_2eproto_once,
      file_level_metadata_protobufs_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgVector*
Arena::CreateMaybeMessage< ::CMsgVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgVector >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgQAngle*
Arena::CreateMaybeMessage< ::CMsgQAngle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgQAngle >(arena);
}
template<> PROTOBUF_NOINLINE ::CInButtonStatePB*
Arena::CreateMaybeMessage< ::CInButtonStatePB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInButtonStatePB >(arena);
}
template<> PROTOBUF_NOINLINE ::CSubtickMoveStep*
Arena::CreateMaybeMessage< ::CSubtickMoveStep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSubtickMoveStep >(arena);
}
template<> PROTOBUF_NOINLINE ::CBaseUserCmdPB*
Arena::CreateMaybeMessage< ::CBaseUserCmdPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CBaseUserCmdPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CSGOInterpolationInfoPB*
Arena::CreateMaybeMessage< ::CSGOInterpolationInfoPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSGOInterpolationInfoPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CSGOInputHistoryEntryPB*
Arena::CreateMaybeMessage< ::CSGOInputHistoryEntryPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSGOInputHistoryEntryPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CSGOUserCmdPB*
Arena::CreateMaybeMessage< ::CSGOUserCmdPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSGOUserCmdPB >(arena);
}
template<> PROTOBUF_NOINLINE ::CUserMessage_Inventory_Response_InventoryDetail*
Arena::CreateMaybeMessage< ::CUserMessage_Inventory_Response_InventoryDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CUserMessage_Inventory_Response_InventoryDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::CUserMessage_Inventory_Response*
Arena::CreateMaybeMessage< ::CUserMessage_Inventory_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CUserMessage_Inventory_Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
